NATs/TTDs:

# Implement "explosion" and subsequent "death" of an agent as follows:
  > define another max score, which i'll call "explScore", and set to something like 1024
  > OnCollide will now constrain to this score and [0] as the min; while
  > the render method will do (min(100,collideScore)) to get the [0,100] lerped color val
  > when collideScore hits explScore, it:
    - generates an 'explosion effect'
    - marks itself as dead
    - withdraws itself from the SP map
  > some method will need to service all existing dead agents
    - maybe via 'lazy observer' analogous to 'lazy object pool' discussed below?
  > create a 'lazy object pool' system whereby:
    - adding anything is realized via insert counter xor random key {as "new Date()*random()"?}
    - things added are expected to eventually call a "destroy" method on the lazy pool with its key
    - the lazy pool will service all existing such calls appropriately before the end of <update>
  > define a 'explosion effects' object which:
    - is instantiated by imminently dead agent, s.t. thrown into lazy pool for per-frame persistance
    - does cool VFX such as expanding-then-retracting orange radius, particle fireworks, etc.
    - when done, tells the pool to destroy it